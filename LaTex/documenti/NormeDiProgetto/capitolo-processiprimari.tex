\section{Processi primari}

\subsection{Fornitura}
\subsubsection{Studio di Fattibilità}
In seguito ad una discussione tra i componenti del gruppo sui capitolati proposti, è compito degli \Analisti{} redigere lo \textit{Studio di Fattibilità} di tali capitolati. Devono essere analizzati:
\begin{itemize}
	\item dominio tecnologico e applicativo: si valutano la conoscenza pregressa delle tecnologie richieste e del dominio applicativo;
	\item utenza: si valuta l'insieme di utenti a cui è rivolto il prodotto;
	\item rapporto costi/benefici: si valutano prodotti già esistenti, possibilità di affermazione nel mercato, costi di realizzazione e benefici del prodotto finito;
	\item rischi: si individuano i punti critici in cui la realizzazione potrebbe incorrere, a partire dalla conoscenza del dominio, fino alla verifica dei requisiti.
\end{itemize}
Deve essere quindi convocata una riunione interna per la decisione finale sul capitolato su cui svolgere il progetto.

\subsection{Sviluppo}

\subsubsection{Analisi dei Requisiti}
\paragraph{Ricerca dei requisiti}\mbox{}\\
Le funzionalità che caratterizzeranno il prodotto alla fornitura vengono concordate con gli \glossario{stakeholders} al momento della presentazione del capitolato d'appalto e attraverso il \glossario{gathering} di informazioni durante le riunioni. Viene fornita nel documento apposito \AnalisiDeiRequisiti{} la descrizione da parte del fornitore del suddetto prodotto.\\
Per assicurare una corretta e completa analisi deve essere stilato l'elenco dei casi d'uso.\\
Ogni caso d'uso deve essere descritto in modo formale seguendo le direttive presenti nel paragrafo \sezione{modellazione-casi-uso}.\\
I requisiti devono essere descritti fino al massimo livello di dettaglio nella Tabella dei Requisiti presente nel documento \AnalisiDeiRequisiti, includendo una descrizione delle fonti da cui derivano, siano esse interne o esterne.

\subparagraph{Modellazione dei casi d'uso}\mbox{}\label{modellazione-casi-uso}\\
Ogni caso d'uso deve essere descritto con:
\begin{itemize}
	\item titolo;
	\item attori;
	\item scopo e descrizione breve;
	\item precondizioni;
	\item flusso principale degli eventi, considerando eventuali distinzioni dei casi al suo interno;
	\item post-condizione.
\end{itemize}
Il caso d'uso deve essere accompagnato da un grafico riassuntivo in \glossario{UML} 2.5, titolato come il caso d'uso.\\
I casi d'uso devono essere catalogati secondo le seguenti norme:
\begin{center}
	UC[numero][caso]
\end{center}
dove:
\begin{itemize}
	\item \textit{UC} specifica che si sta parlando di un caso d'uso;
	\item \textit{numero} è assoluto e rappresenta un riferimento univoco al caso d'uso in questione;
	\item \textit{caso} individua eventuali diramazioni all'interno dello stesso caso d’uso.
\end{itemize}

\subparagraph{Classificazione dei requisiti}\mbox{}\\
I requisiti emersi dal capitolato devono essere catalogati secondo le seguenti norme:
\begin{center}
	R[utilità strategica][attributi di prodotto][numero]
\end{center}
dove:
\begin{itemize}
	\item \textit{R} specifica che si sta parlando di un requisito;
	\item \textit{utilità strategica} assume uno dei seguenti valori:
	\begin{enumerate}
		\item se il requisito è obbligatorio;
		\item se il requisito è desiderabile;
		\item se il requisito è opzionale.
	\end{enumerate}
	\item \textit{attributi di prodotto} assume uno dei seguenti valori:
	\begin{itemize}
		\item [F] se il requisito è funzionale;
		\item [P] se il requisito è prestazionale;
		\item [Q] se il requisito è di qualità;
		\item [V] se il requisito è di vincolo.
	\end{itemize}
	\item \textit{numero} è assoluto e rappresenta un riferimento univoco al requisito in questione.
\end{itemize}

\paragraph{Tracciamento}\mbox{}\\
\`{E} compito degli \Analisti{} controllare la corrispondenza tra i requisiti e le loro fonti (capitolato, casi d'uso, verbali di riunioni). Questa corrispondenza deve essere presentata nelle due tabelle di tracciamento Fonti-Requisiti e Requisiti-Fonti per facilitarne la consultazione. 

\subsubsection{Progettazione}
\paragraph{Specifica Tecnica}\mbox{}\\
\`{E} compito dei \Progettisti{} descrivere la \PA{} ad alto livello del prodotto nella \SpecificaTecnica.

\subparagraph{Diagrammi UML}\mbox{}\\
Devono essere realizzati i seguenti diagrammi:
\begin{itemize}
	\item diagrammi dei \glossario{package};
	\item diagrammi delle classi;
	\item diagrammi di sequenza;
	\item diagrammi di attività.
\end{itemize}

\subparagraph{Design pattern}\mbox{}\\
Devono essere descritti i \glossario{design pattern} utilizzati specificando:
\begin{itemize}
	\item scopo del design pattern;
	\item funzionamento del design pattern;
	\item diagramma delle classi generico del design pattern.
\end{itemize}

\subparagraph{Tracciamento Componenti}\mbox{}\\
Deve essere tracciata la corrispondenza tra requisiti e componenti che li soddisfano.

\paragraph{Definizione di Prodotto}\mbox{}\\
\`{E} compito dei \Progettisti{} stilare la \DefinizioneDiProdotto, in cui è descritta la \PD{} del prodotto, ampliando quanto detto nella \SpecificaTecnica.

\subparagraph{Diagrammi UML}\mbox{}\\
Devono essere aggiornati i seguenti diagrammi:
\begin{itemize}
	\item Diagrammi delle classi;
	\item Diagrammi di sequenza;
	\item Diagrammi di attività.
\end{itemize}

\subparagraph{Definizione di Classe}\mbox{}\\
Nella \DefinizioneDiProdotto{} deve essere descritta ogni classe progettata, secondo lo standard UML 2.5. La descrizione deve essere costituita da:
\begin{itemize}
	\item \textbf{attributi}: vanno indicati l'accessibilità, il nome e la descrizione di ognuno;
	\item \textbf{metodi}: vanno indicati l'accessibilità, il nome e la descrizione di ognuno;
	\item \textbf{parametri}: vanno racchiusi tra parentesi tonde e devono essere riportati con nome e tipo, separati da due punti;
	\item \textbf{argomenti}: vanno indicati la direzione tra parentesi quadre, nome e tipo separati da due punti, seguiti da una breve descrizione.
\end{itemize}
Ogni classe deve inoltre essere accompagnata da una descrizione che ne includa lo scopo e le funzionalità.

\subparagraph{Tracciamento delle Classi}\mbox{}\\
Deve essere tracciata la corrispondenza tra requisiti e classi che li soddisfano.

\subparagraph{Test}\mbox{}\\
\`{E} compito dei \Progettisti{} configurare in modo adeguato i test di unità e di integrazione, tramite \glossario{driver}, \glossario{stub} ed altri eventuali strumenti.\\
\`{E} responsabilità del \Programmatore{} attuare i test di unità più semplici, mentre i restanti devono essere eseguiti tramite strumenti automatici.\\
I test di integrazione devono essere eseguiti tramite strumenti automatici quando possibile. \`{E} compito dei \Verificatori{} verificarne l'integrità.\\
Devono essere eseguiti inoltre test di regressione in caso di modifiche, per accertare che queste non causino errori nelle parti già sottoposte a verifica con esito positivo. In questo modo viene garantito che le modifiche effettuate non pregiudichino le funzionalità esistenti e già testate.

\paragraph{Metriche per la progettazione}\mbox{}\\
Si concentrano sulle caratteristiche dell'architettura ad alto livello. Si basano sull'analisi di modelli di progetto nei quali sono evidenziati i moduli di sistema e i dati scambiati.

\subparagraph{Accoppiamento}\mbox{}\\
L'accoppiamento determina il numero di collaborazioni tra classi, ovvero il numero di altre classi cui una classe è accoppiata.\\
L'accoppiamento può avvenire a seguito di lettura o modifica di attributi, chiamata di metodi o istanziazione di oggetti. Un uso eccessivo è negativo per la modularità ed il riuso: più una classe è indipendente più è riutilizzabile. L'accoppiamento influisce anche sull'impatto delle modifiche in altri moduli: valori elevati di accoppiamento complicano le attività di testing e le modifiche.
\[ U = M \cdot N \]
$M$ componenti in accoppiamento con $N$ altri componenti producono un grado di interdipendenza $U$.
\textit{Fan-In} denomina quante classi utilizzano la classe presa in esame durante la loro esecuzione, Fan-In determina la dipendenza dal resto del codice prodotto. 
\textit{Fan-Out} denomina quante classi vengono utilizzate dalla classe presa in esame durante la sua esecuzione, alti livelli di Fan-Out determinano alti livelli di accoppiamento rendendo il codice complesso da testare, livelli bassi di Fan-Out corrispondono a codice più facilmente riusabile per altri scopi dato che è indipendente totalmente o quasi dal resto del progetto.

\subparagraph{Complessità ciclomatica}\mbox{}\\
Questa tecnica utilizza elementi della teoria dei grafi per schematizzare il flusso di controllo del programma. Rappresenta gruppi di istruzioni in nodi e le interazioni fra loro in archi: i nodi corrispondono ai gruppi di istruzioni, mentre gli archi connettono gruppi di istruzioni che possono essere eseguite sequenzialmente.\\
Dato un grafo $G$ di $n$ nodi ed $e$ archi, la complessità ciclomatica è data da:
\[ V\left(G\right) = e - n + 2 \]
Valori alti di complessità indicano poca manutenibilità del codice e maggiore quantità di test per la verifica, ma valori bassi possono indicare poca efficienza.

\subsubsection{Codifica}
Tutti i file contenenti codice o documentazione dovranno essere conformi alla codifica \glossario{UTF-8}.

\paragraph{Convenzioni} \label{sec:convenzioni}\mbox{}\\
Al fine di ottimizzare il passaggio tra progettazione e prodotto finale, i \Programmatori{} sono tenuti a rispettare le convenzioni che seguono.\\
Si è deciso di seguire le linee guida specificate nel capitolato e concordate con il proponente:
\begin{itemize}
	\item \glossario{Airbnb JavaScript style guide}\footnote{\url{https://github.com/airbnb/javascript}};
	\item \glossario{12 Factors app}\footnote{\url{https://12factor.net/}} documentandone l'utilizzo;
	\item limitare i commenti alle sole parti di codice che richiedano una spiegazione immediata del loro funzionamento;
	\item evitare le \glossario{callback}, o motivarne opportunamente l’uso.
\end{itemize}
\paragraph{Ricorsione}\mbox{}\\
La ricorsione deve essere evitata quando possibile, onde evitare un elevato consumo di memoria a discapito delle performance del prodotto finale.

\paragraph{Metriche per la codifica}\mbox{}
\subparagraph{Numero di parametri per funzione}\mbox{}\\
Indica il numero di parametri passati ad un metodo; un valore molto alto potrebbe indicare eccessiva complessità e una suddivisione non efficace in sotto-metodi.

\subparagraph{Metriche di Halstead}\mbox{}\\
Misurano l'implementazione del programma in base al codice sorgente considerato come un algoritmo, quindi come un insieme di operatori e operandi.\\
Vengono così contrassegnati i componenti del codice:
\begin{itemize}
	\item $\eta_{1}$ = numero di operatori distinti;
	\item $\eta_{2}$ = numero di operandi distinti;
	\item $N1$ = numero totale di occorrenze degli operatori; 
	\item $N2$ = numero totale di occorrenze degli operandi;
\end{itemize}
Secondo questa marcatura possiamo calcolare:
\begin{itemize}
	\item il vocabolario del programma:
	\[ \eta = \eta_{1} + \eta_{2} \]
	\item la lunghezza del programma:
	\[ N = N1 + N2 \]
	\item la lunghezza calcolata del programma: 
	\[ {\hat {N}}=\eta_{1} \cdot \log_{2}\eta_{1}+\eta_{2} \cdot \log_{2}\eta_{2} \]
	\item il volume del programma:
	\[ V = N \cdot \log_{2}\eta \] 
	dove
	\begin{itemize}
		\item $ \log_{2}\eta $ è il numero di bit necessari per rappresentare il vocabolario;
		\item $ V $ è il numero di bit necessari per rappresentare il programma nella sua forma minima.\footnote{Il concetto di volume è legato quindi al contenuto di informazione del programma e dovrebbe dipendere unicamente dall'algoritmo scelto, non dall'espressività del linguaggio di programmazione.}
	\end{itemize}
	\item la difficoltà di scrittura e comprensione del programma:
	\[ D = \frac{\eta_{1}}{2} \cdot \frac{N_{2}}{\eta_{2}} \]
	\item lo sforzo complessivo sostenuto nella scrittura del programma:
	\[ E = D \cdot V \]
	\item il tempo di scrittura del programma:
	\[ T=\frac{E}{18}\ secondi\]
	\item il numero di bug in proporzione allo sforzo richiesto:
	\[ B = \frac{E^{\frac{2}{3}}}{3000} \]	
\end{itemize}

\subparagraph{Core size}\mbox{}\\
I core file sono file altamente interconnessi da una catena di dipendenze cicliche, i quali sono maggiormente propensi ad avere difetti. Core size è la percentuale di file con una o più dipendenze che hanno un alto fan-in ed un alto fan-out. Il calcolo di questa metrica viene effettuato attraverso strumenti automatici.

\subparagraph{Indice di manutenibilità}\mbox{}\\
Misura l’attitudine di una entità in assegnate condizioni di utilizzazione a essere mantenuta o riportata in uno stato nel quale può svolgere la funzione richiesta, quando la manutenzione è eseguita nelle condizioni date, con procedure e mezzi prescritti. Viene calcolato attraverso strumenti automatici.

\paragraph{Metriche per la verifica}\mbox{}
\subparagraph{Code coverage}\mbox{}\\
Misura la capacità di coprire, mediante esecuzione di test, tutte le linee di codice di un modulo. Una copertura topologica del test del 100\% di tipo code coverage garantisce di aver eseguito almeno una volta tutte le istruzioni, ma non tutti i rami.

\subparagraph{Modified condition/decision coverage (MC/DC)}\mbox{}\\
\`{E} una combinazione delle metriche di \textit{function coverage} (copertura delle funzioni chiamate) e \textit{branch coverage} (copertura dei branch delle strutture di controllo). Questa metrica richiede che ogni punto di entrata o uscita in un programma sia invocato almeno una volta e che per ogni decisione condizionale vengano considerati tutti i possibili esiti. La versione \textit{modified} richiede inoltre che entrambe le coperture siano soddisfatte, ed in particolare che ogni condizione influenzi gli esiti condizionali indipendentemente.\footnote{Si rimanda al seguente link \url{https://en.wikipedia.org/wiki/Code_coverage} per esempi esplicativi.}

\subparagraph{Test eseguiti}\mbox{}
Rappresenta la percentuale di test eseguiti rispetto a quelli pianificati. Viene calcolata come
\[\frac{N_{TE}}{N_{TT}} \cdot 100 \]
dove
\begin{itemize}
	\item $N_{TE}$: numero di test eseguiti;
	\item $N_{TT}$: numero di test totali pianificati.
\end{itemize}

\subparagraph{Test superati}\mbox{}\\
Indica la percentuale di test superati rispetto a quelli eseguiti. Viene calcolata come
\[ \frac{N_{TS}}{N_{TE}} \cdot 100 \]
dove
\begin{itemize}
	\item $N_{TS}$: numero di test superati;
	\item $N_{TE}$: numero di test eseguiti.
\end{itemize}

\subparagraph{Metriche di gestione degli errori}\mbox{}\\
I parametri utilizzati:
\begin{itemize}
	\item \textbf{Criticità}: indica la gravità dell'errore rispetto all'avanzamento del progetto. Può assumere i seguenti valori:
	\begin{itemize}
		\item \textbf{bassa}: l'errore non compromette il corretto avanzamento del progetto;
		\item \textbf{media}: l'errore non è bloccante, ma può compromettere il corretto avanzamento del progetto;
		\item \textbf{alta}: l'errore è bloccante e compromette l'avanzamento del progetto.	
	\end{itemize}
	\item \textbf{Priorità}: indica la priorità di risoluzione dell'errore. Può assumere i seguenti valori:
	\begin{itemize}
		\item \textbf{bassa}: l'errore deve essere risolto entro la milestone successiva;
		\item \textbf{media}: l'errore deve essere risolto entro una settimana dalla segnalazione;
		\item \textbf{alta}: l'errore deve essere risolto nel più breve tempo possibile.
	\end{itemize}
	\item \textbf{Modalità}: indica la modalità di gestione dell'errore. Può assumere i seguenti valori:
	\begin{itemize}
		\item \textbf{correzione immediata}: il \Verificatore{} può correggere immediatamente l'errore se ne è in grado;
		\item \textbf{segnalazione}: il \Verificatore{} deve effettuare una segnalazione, secondo le procedure indicate nelle \NormeDiProgetto{}.
	\end{itemize}
\end{itemize}

\subsubsection{Metriche di prodotto}
Hanno l'obiettivo di misurare la qualità del prodotto software nelle sue caratteristiche fisiche quali dimensioni, funzionabilità, manutenibilità e usabilità.

\paragraph{Functional Size Measurement}\mbox{}\\
Functional Size Measurement (FSM) è una tecnica per misurare il software in termini di funzionalità che esso offre. Lo standard \glossario{ISO}/\glossario{IEC} 14143 definisce FSM come una quantificazione dei Functional User Requirements (FUR), ovvero i requisiti che descrivono ciò che il software dovrebbe fare in termini di compiti e servizi, escludendo quindi le costrizioni in termini di qualità, organizzazione, ambiente e implementazione.\\
Vantaggi di FSM:
\begin{itemize}
	\item è indipendente dalla tecnologia usata per implementare e sviluppare il software;
	\item è idealmente la componente misurativa delle prestazioni del progetto, poiché queste possono essere comparate come le varie tecnologie, piattaforme, e altro ancora;
	\item può essere stimata dallo stato dei requisiti a priori.
\end{itemize}
\`{E} pertanto utilizzabile per una valutazione preventiva dei costi del progetto.\\
Il calcolo della copertura offerta è effettuato mediante la formula
\[ \left(1 - \frac{N_{FM}}{N_{FI}} \right) \cdot 100 \]
dove
\begin{itemize}
	\item $N_{FM}$: numero di funzionalità mancanti;
	\item $N_{FI}$: numero di funzionalità individuate. 
\end{itemize}

\paragraph{Accuratezza rispetto alle attese}\mbox{}\\
Rappresenta la percentuale di risultati dei test che rispettano quanto previsto. Viene calcolata come
\[ \left(1 - \frac{N_{RD}}{N_{TE}} \right) \cdot 100 \]
dove
\begin{itemize}
	\item $N_{RD}$: numero di test che producono risultati discordanti;
	\item $N_{TE}$: numero di test eseguiti.
\end{itemize}

\paragraph{Fallimento dei test}\mbox{}\\
Rappresenta la percentuale di operazioni di test che si sono concluse con fallimento. Viene calcolato come
\[ \frac{N_{FR}}{N_{TE}} \cdot 100\]
dove
\begin{itemize}
	\item $N_{FR}$: numero di fallimenti ricevuti;
	\item $N_{TE}$: numero di test eseguiti.
\end{itemize}

\paragraph{Gestione delle operazioni non permesse}\mbox{}\\
Rappresenta la percentuale di funzionalità che gestiscono correttamente errori che potrebbero verificarsi. Viene calcolato come
\[ \frac{N_{EE}}{N_{TE}} \cdot 100\]
dove
\begin{itemize}
	\item $N_{EE}$: numero di errori evitati durante i test;
	\item $N_{TE}$: numero di test eseguiti che prevedono l'esecuzione di operazioni non corrette.
\end{itemize} 


\subsection{Verifica}
L’attività di verifica deve essere svolta in modo continuativo durante l'avanzamento del progetto. Sono quindi definite modalità operative per agevolare il lavoro dei \Verificatori.

\subsubsection{Analisi statica}
\`{E} prevista l'attività di analisi statica, applicata a tutti i processi del progetto, per individuare errori nella documentazione e nel software prodotto. Viene eseguita da \Verificatori{} e \Programmatori{}, con ruoli distinti.

\paragraph{Walkthrough} \mbox{}\\
Si esegue una lettura critica del documento (o codice), a largo spettro e senza alcun presupposto. A seguito di questa attività deve essere redatta una lista che riporti gli errori rilevati con più frequenza, la quale verrà inserita in questo documento per favorire l'uso della tecnica \glossario{inspection} nelle verifiche successive.

\paragraph{Inspection} \mbox{}\\
Si esegue una lettura mirata del documento (o codice), focalizzando la ricerca sui presupposti individuati tramite precedenti analisi \glossario{walkthrough}.

\paragraph{Linting}\mbox{}\\
Vengono identificate nel codice prodotto strutture che non rispettano le linee guida imposte tramite strumenti automatici che analizzano il codice e individuano pattern indesiderati o discrepanze.\\
Alcuni di questi sono:\begin{itemize}
	\item variabili usate prima di essere inizializzate;  
	\item divisioni per zero;
	\item condizioni costanti;
	\item operazioni il cui risultato probabilmente potrebbe risultare esterno all'intervallo di valori rappresentabili con il tipo usato.
\end{itemize}
Lo strumento utilizzato per questo tipo di analisi è \glossario{ESLint}, ottimizzato per la Airbnb JavaScript style guide indicata in \sezione{sec:convenzioni} di questo documento. ESLint viene descritto in \sezione{sec:eslint}.

\subparagraph{Complexity report}\mbox{}\\
È un'applicazione installabile come modulo per \glossario{Node.js} e misura metriche riguardanti codice \glossario{JavaScript}, in particolare:
\begin{itemize}
	\item complessità ciclomatica;
	\item numero di parametri per funzioni;
	\item Halstead;
	\item core size;
	\item indice di manutenibilità.
\end{itemize}

\subparagraph{Analisi dinamica}\mbox{}\\
\`{E} prevista l’attività di analisi dinamica per il software prodotto per verificarne il corretto funzionamento, in quanto si avvale dell'esecuzione di test su di esso.
Vengono utilizzati gli strumenti \glossario{Mocha} e \glossario{Chai}, integrati con lo strumento di testing offerto da \glossario{Meteor}.\footnote{Per maggiori dettagli si rimanda al sito ufficiale https://guide.meteor.com/testing.html}

\paragraph{Test}\mbox{}\\
Vengono svolti vari test, riportati nel \PianoDiQualifica{} e catalogati come segue:
\begin{center}
	T[tipo][numero]
\end{center}
dove
\begin{itemize}
	\item \textit{T} specifica che si sta parlando di un test;
	\item \textit{tipo} assume uno dei seguenti valori:
	\begin{itemize}
		\item [U] se il test è di unità;
		\item [I] se il test è di integrazione;
		\item [R] se il test è di regressione;
		\item [S] se il test è di sistema;
		\item [V] se il test è di validazione.
	\end{itemize}
	\item \textit{numero} è assoluto e rappresenta un riferimento univoco al test in questione.
\end{itemize}
In particolare:
\begin{itemize}
	\item i test di unità verificano che le singole componenti non abbiano errori prese individualmente;
	\item i test di integrazione verificano che più unità collaborino correttamente;
	\item i test di regressione verificano che le modifiche apportate non invalidino i test già svolti in precedenza;
	\item i test di sistema verificano che il prodotto soddisfi tutti i requisiti;
	\item i test di validazione coincidono con il collaudo finale.
\end{itemize}

\subsection{Validazione}
L’attività di Validazione è necessaria per assicurare che il prodotto sia conforme ai requisiti.
La validazione può essere eseguita attraverso i Test di Sistema per confermare che l'architettura progettata sia funzionante, corretta e soddifi tutti i requisti. 
In corrispondenza della /RA tramite test di Validazione si esegue il collaudo finale volto a verificare la soddisfazione del Proponente.


